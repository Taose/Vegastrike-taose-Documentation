\hypertarget{classAudio_1_1Codec}{}\section{Audio\+:\+:Codec Class Reference}
\label{classAudio_1_1Codec}\index{Audio\+::\+Codec@{Audio\+::\+Codec}}


{\ttfamily \#include $<$Codec.\+h$>$}



Inheritance diagram for Audio\+:\+:Codec\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=280pt]{d5/dd7/classAudio_1_1Codec__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Audio\+:\+:Codec\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=174pt]{db/d4c/classAudio_1_1Codec__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::vector$<$ std\+::string $>$ \hyperlink{classAudio_1_1Codec_a2f2e8eb4d85b0e5b338764adfa4bc881}{Extensions}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
const std\+::string \& \hyperlink{classAudio_1_1Codec_a7ecc8f41ee30126119376f6ca096af23}{get\+Name} () const   throw ()
\item 
virtual const \hyperlink{classAudio_1_1Codec_a2f2e8eb4d85b0e5b338764adfa4bc881}{Extensions} $\ast$ \hyperlink{classAudio_1_1Codec_af898298ac49f9bc82db8f352159014ef}{get\+Extensions} () const   throw ()
\item 
virtual bool \hyperlink{classAudio_1_1Codec_aaae42e87264f1bfa7a75ed041c4432fb}{can\+Handle} (const std\+::string \&path, bool can\+Open, V\+S\+File\+System\+::\+V\+S\+File\+Type type=V\+S\+File\+System\+::\+Unknown\+File)=0  throw ()
\item 
virtual \hyperlink{classAudio_1_1Stream}{Stream} $\ast$ \hyperlink{classAudio_1_1Codec_ace346d58a094f8c467cb152da061f82e}{open} (const std\+::string \&path, V\+S\+File\+System\+::\+V\+S\+File\+Type type=V\+S\+File\+System\+::\+Unknown\+File)=0  throw (\+Exception)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classAudio_1_1Codec_ae4d9035b22c35be2dcc48a2e6531e9b6}{Codec} (const std\+::string \&name)  throw ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{classAudio_1_1Codec}{Codec} factory class.

\begin{DoxyRemark}{Remarks}
Use it to create \hyperlink{classAudio_1_1Stream}{Stream} instances attached to a file. 
\end{DoxyRemark}
\begin{DoxySeeAlso}{See also}
\hyperlink{classAudio_1_1CodecRegistry}{Codec\+Registry} to create \hyperlink{classAudio_1_1Codec}{Codec} instances. 
\end{DoxySeeAlso}


\subsection{Member Typedef Documentation}
\index{Audio\+::\+Codec@{Audio\+::\+Codec}!Extensions@{Extensions}}
\index{Extensions@{Extensions}!Audio\+::\+Codec@{Audio\+::\+Codec}}
\subsubsection[{\texorpdfstring{Extensions}{Extensions}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<$std\+::string$>$ {\bf Audio\+::\+Codec\+::\+Extensions}}\hypertarget{classAudio_1_1Codec_a2f2e8eb4d85b0e5b338764adfa4bc881}{}\label{classAudio_1_1Codec_a2f2e8eb4d85b0e5b338764adfa4bc881}
Back-\/appendable collection of std\+::string, optimally for static readonly data 

\subsection{Constructor \& Destructor Documentation}
\index{Audio\+::\+Codec@{Audio\+::\+Codec}!Codec@{Codec}}
\index{Codec@{Codec}!Audio\+::\+Codec@{Audio\+::\+Codec}}
\subsubsection[{\texorpdfstring{Codec(const std\+::string \&name)}{Codec(const std::string &name)}}]{\setlength{\rightskip}{0pt plus 5cm}Audio\+::\+Codec\+::\+Codec (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name}
\end{DoxyParamCaption}
) throw  ) \hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classAudio_1_1Codec_ae4d9035b22c35be2dcc48a2e6531e9b6}{}\label{classAudio_1_1Codec_ae4d9035b22c35be2dcc48a2e6531e9b6}
Internal constructor 

\subsection{Member Function Documentation}
\index{Audio\+::\+Codec@{Audio\+::\+Codec}!can\+Handle@{can\+Handle}}
\index{can\+Handle@{can\+Handle}!Audio\+::\+Codec@{Audio\+::\+Codec}}
\subsubsection[{\texorpdfstring{can\+Handle(const std\+::string \&path, bool can\+Open, V\+S\+File\+System\+::\+V\+S\+File\+Type type=\+V\+S\+File\+System\+::\+Unknown\+File)=0}{canHandle(const std::string &path, bool canOpen, VSFileSystem::VSFileType type=VSFileSystem::UnknownFile)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool Audio\+::\+Codec\+::can\+Handle (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path, }
\item[{bool}]{can\+Open, }
\item[{V\+S\+File\+System\+::\+V\+S\+File\+Type}]{type = {\ttfamily VSFileSystem\+:\+:UnknownFile}}
\end{DoxyParamCaption}
) throw  ) \hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classAudio_1_1Codec_aaae42e87264f1bfa7a75ed041c4432fb}{}\label{classAudio_1_1Codec_aaae42e87264f1bfa7a75ed041c4432fb}
Returns whether this codec instanc can handle the specified file. 
\begin{DoxyParams}{Parameters}
{\em path} & the file to be tested \\
\hline
{\em can\+Open} & whether opening the file to take a peek is allowed. If not, the implementation should rely on the filename alone to do its task (ie\+: look for an extension). See the remarks for more details.\\
\hline
\end{DoxyParams}
\begin{DoxyRemark}{Remarks}
This member will return true when it thinks the codec can decode the specified file, and false otherwise. No certainty is required. However, an assumption is made that codec implementations will make a reasonable effort to guess the outcome of an \char`\"{}open\char`\"{} call, given the allowed operations. If can\+Open is true, the implementation can open the file to inspect its format and accurately decide that. The operation is still expected to be rather quick. If can\+Open is false, the operation is expected to be even quicker and the implementation may not open the file. Rather, filename patterns (or any other method that doesn\textquotesingle{}t open the file) are the only viable methods of implementation, and thus it is expected that the returned value will be less accurate. Whenever in doubt, the function will return success (true). 
\end{DoxyRemark}


Implemented in \hyperlink{classAudio_1_1OggCodec_af8071151d8920b49f7ca5ed1c826ee80}{Audio\+::\+Ogg\+Codec}, and \hyperlink{classAudio_1_1FFCodec_ab13399f816a4665befa72222aba6c81e}{Audio\+::\+F\+F\+Codec}.

\index{Audio\+::\+Codec@{Audio\+::\+Codec}!get\+Extensions@{get\+Extensions}}
\index{get\+Extensions@{get\+Extensions}!Audio\+::\+Codec@{Audio\+::\+Codec}}
\subsubsection[{\texorpdfstring{get\+Extensions() const }{getExtensions() const }}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$ std\+::string $>$ $\ast$ Audio\+::\+Codec\+::get\+Extensions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const throw  ) \hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classAudio_1_1Codec_af898298ac49f9bc82db8f352159014ef}{}\label{classAudio_1_1Codec_af898298ac49f9bc82db8f352159014ef}
Return a list of supported extensions. \begin{DoxyRemark}{Remarks}
If it returns something, it is expected that files handled by this codec be named by appending one of the returned extensions as a suffix. 
\end{DoxyRemark}
\begin{DoxyParagraph}{Though supported extensions are a big help to the codec registry}
when asked to suggest codecs for a file, a null value can be returned asking the registry to always try this codec. This is useful if the codec can handle many (perhaps unknown) file types, or if there is no associated extension to the type handled. 
\end{DoxyParagraph}
\begin{DoxyParagraph}{The base implementation does just that -\/ returns null.}

\end{DoxyParagraph}
\begin{DoxyParagraph}{It is expected that files named with returned extensions will pass the}
tests for can\+Handle(path,false). Though this may not always be true. So the final test can\+Handle(path,true) should never be skipped, even if the file includes an extension within the returned set. 
\end{DoxyParagraph}


Reimplemented in \hyperlink{classAudio_1_1OggCodec_acc8ecbc48b092d851b2e9280234f1cdd}{Audio\+::\+Ogg\+Codec}.

\index{Audio\+::\+Codec@{Audio\+::\+Codec}!get\+Name@{get\+Name}}
\index{get\+Name@{get\+Name}!Audio\+::\+Codec@{Audio\+::\+Codec}}
\subsubsection[{\texorpdfstring{get\+Name() const }{getName() const }}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string \& Audio\+::\+Codec\+::get\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const throw  ) }\hypertarget{classAudio_1_1Codec_a7ecc8f41ee30126119376f6ca096af23}{}\label{classAudio_1_1Codec_a7ecc8f41ee30126119376f6ca096af23}
Return the descriptive name of the codec. \index{Audio\+::\+Codec@{Audio\+::\+Codec}!open@{open}}
\index{open@{open}!Audio\+::\+Codec@{Audio\+::\+Codec}}
\subsubsection[{\texorpdfstring{open(const std\+::string \&path, V\+S\+File\+System\+::\+V\+S\+File\+Type type=\+V\+S\+File\+System\+::\+Unknown\+File)=0}{open(const std::string &path, VSFileSystem::VSFileType type=VSFileSystem::UnknownFile)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Stream}$\ast$ Audio\+::\+Codec\+::open (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path, }
\item[{V\+S\+File\+System\+::\+V\+S\+File\+Type}]{type = {\ttfamily VSFileSystem\+:\+:UnknownFile}}
\end{DoxyParamCaption}
) throw  {\bf Exception}) \hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classAudio_1_1Codec_ace346d58a094f8c467cb152da061f82e}{}\label{classAudio_1_1Codec_ace346d58a094f8c467cb152da061f82e}
Returns an instance of the \hyperlink{classAudio_1_1Stream}{Stream} class attached to this codec and the specified file.


\begin{DoxyParams}{Parameters}
{\em path} & the file to be attached to the returned object. \\
\hline
{\em type} & (optional) the type of file, used by resource management A\+P\+Is. \\
\hline
\end{DoxyParams}
\begin{DoxyRemark}{Remarks}
Don\textquotesingle{}t even bother to call it if can\+Handle returns false. However, if it returns true, this can still fail. Be prepared to catch exceptions and deal with them accordingly. 
\end{DoxyRemark}


Implemented in \hyperlink{classAudio_1_1OggCodec_a23ea17b563b23f37bd607932ccb9a06d}{Audio\+::\+Ogg\+Codec}, and \hyperlink{classAudio_1_1FFCodec_aa8e9f3e49b9bb3634302642805a3630a}{Audio\+::\+F\+F\+Codec}.



Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=332pt]{d2/d14/classAudio_1_1Codec_ace346d58a094f8c467cb152da061f82e_icgraph}
\end{center}
\end{figure}




The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
audio/codecs/Codec.\+h\item 
audio/codecs/Codec.\+cpp\end{DoxyCompactItemize}
